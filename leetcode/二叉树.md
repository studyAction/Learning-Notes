# 1.[剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

##	题解

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(B == NULL || A == NULL)
            return false;
        //遍历A中每个节点，A树中任一节点包含B就能返回true
        return iscontain(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
    //包含：以A为根的数是否包含B（必须从A开始）
    bool iscontain(TreeNode* A, TreeNode* B){
        if(B == NULL)
            return true;
        if(A == NULL || A->val != B->val)
            return false;
        return iscontain(A->left, B->left) && iscontain(A->right, B->right);
    }
};
```

## 总结

1. 主函数主体时先序遍历的思想，因为返回值表示的是
2. 对于递归函数recur的解析
   1. 当节点B为空，说明B已经匹配完毕，返回true
   2. 当节点A为空，说明A已经匹配完，匹配失败，返回false
   3. 当A与B的节点值不一样时，返回false
3. 递归子结构
   1. 判断A与B的左子节点是否一样
   2. 判断A与B的右子节点是否一样



# 2. [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

## 题解

```c++
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(root ==NULL) {
            return NULL;
        }
        TreeNode* left = mirrorTree(root->left);
        TreeNode* right = mirrorTree(root->right);
        root->left = right;
        root->right = left;
        return root;
    }

};
```

## 错误题解

```c++
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        recur(root);
        return root;
    }

    void recur(TreeNode* root) {
        if(root == NULL || root->left == NULL || root->right == NULL) {
            return ;
        }
        recur(root->right);
        recur(root->left);
        swap(root->left, root->right);
    }
};
```



## 总结

类似于后续遍历，从逻辑上来说，要先交换底层节点，再交换高层节点



# 3.[剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

## 递归法

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == NULL) {
            return true;
        }
        return recur(root->left, root->right);
    }
    bool recur(TreeNode* root1, TreeNode* root2) {
        // 递归边界1:同时遍历完
        if(root1 == NULL && root2 == NULL) {
            return true;
        }
        // 递归边界2：有一个子树未遍历完
        if(root1 == NULL || root2 == NULL) {
            return false;
        }
        // 递归的主体：值相等、左左==右右、左右==右左
        return root1->val == root2->val 
                && recur(root1->left, root2->right) 
                && recur(root1->right, root2->left);
    }
};
```

严格按照递归三要素：**递归参数的确定、递归中止条件、递归的子问题**

## **基于队列的迭代法**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == NULL) {
            return true;
        }
        queue<TreeNode*> que;
        que.push(root->left);
        que.push(root->right);
        while(!que.empty()) {
            TreeNode* left = que.front();
            que.pop();
            TreeNode* right = que.front();
            que.pop();
            if(left == NULL && right == NULL) {
                continue;
            }
            if(left == NULL || right == NULL || (left->val != right->val)) {
                return false;
            }
            que.push(left->left);
            que.push(right->right);
            que.push(left->right);
            que.push(right->left);
        }
        return true;
    }
};
```



