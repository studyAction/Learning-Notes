# 回溯

<img src="https://img-blog.csdnimg.cn/20210219192050666.png" alt="回溯算法大纲" style="zoom:50%;" align='left' />

计划每天三题，一周正好结束

## backtracking template

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



## 1、[组合](https://leetcode-cn.com/problems/combinations/)

### 优化

剪枝处理，`i <= n - (k - path.size()) + 1`

<img src="https://img-blog.csdnimg.cn/20210130194335207.png" alt="77.组合4" style="zoom:50%;" align='left'/>

```
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int startIndex) {
        if(path.size() == k) {
            result.push_back(path);
            return;
        }
        // for循环表示横向的遍历，递归才是真正的将元素加入到path中
        for(int i = startIndex; i <= n - (k - path.size()) + 1; i++) {
            path.push_back(i);
            backtracking(n, k, i+1);
            path.pop_back(); // 回溯
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```

`n-(k - path.size()) + 1`  对应的是至多可以从哪里开始选取元素加入到path中

case : n = 4, k = 2，path中没有元素时，最多可以从index=3开始

#### 2、[ 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)



```C++
class Solution {
public:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };

    vector<string> result;
    string s;
    void backtracking(string& digits, int index,const string &s) {
        if(index == digits.size()) {
            result.push_back(s);
            return;
        }
        int digit = digits[index] - '0';
        string letters = letterMap[digit];
        for(int i = 0; i < letters.size(); i++) {
            backtracking(digits, index + 1, s + letters[i]);
        }
    }

    vector<string> letterCombinations(string digits) {
        if(digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0, "");
        return result;
    }
};
```

3、[组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

```
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    
    void backtracking(int target, int k, int sum, int startIndex) {
        if(sum > target) {
            return;
        }
        if(path.size() == k) {
            if(target == sum) {
                result.push_back(path);
            }
            return;
        }
        for(int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) {
            sum += i;
            path.push_back(i);
            backtracking(target, k, sum, i+1);
            path.pop_back();
            sum -= i;
        }
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(n, k, 0, 1);
        return result;
    }
};
```

